#!/usr/bin/env perl
use v5.20;
use Mojolicious::Lite;
use List::Util qw/max/;
use experimental 'signatures';
use lib '.';
use Room;
use Data::Dumper;

$ENV{MOJO_INACTIVITY_TIMEOUT} = 120;
sub debug($) { app->log->debug(@_) }

my %players;     # $id => $tx
my $room = Room->new(log => app->log);

app->hook(after_dispatch => sub($c) {
  $c->res->headers->header('Access-Control-Allow-Origin' => '*');
});

helper notify => sub ($c,$us,$game) {
  my $ours = $game->played->{$us};
  my $them = $game->other_player($us);
  my $theirs = $game->played->{$them};
  my $status = $ours eq $theirs ? 'tie'
             : $ours eq $game->winner ? 'win'
             : 'lose';
  $players{$us}->send({
        json => {
            you      => $status,
            yours    => $ours,
            opponent => $them,
            theirs   => $theirs,
            game     => $game->id
        }
    });
};

helper new_player => sub($c) {
  state $i = 1;
  return $i++;
};

get '/' => sub ($c) {
  $c->render(text => "Welcome to ro.  Make a websocket connection to /ready.\n");
};

get '/games' => sub ($c) {
  $c->render(json => { available => $room->available });
};

websocket '/ready' => sub($c) {
  # $us, $them are ids
  # $ours, $theirs are rock/paper/scissors
  $c->on(message => sub ($c,$msg) {

     # Establish connection but don't pair until we play.
     $msg eq 'hello' or return debug 'did not say hello';
     my $us = $c->new_player;
     debug "New player: $us";
     my $tx = $c->tx;
     $tx->send({ json => { welcome => $us } });
     $players{$us} = $tx;
     $tx->unsubscribe('message');

     $tx->on(message => sub ($tx, $ours) {
       $ours =~ /^(rock|paper|scissors)$/ or return $tx->send({ json => { error => "wat? ($ours)" } });
       $room->playing($us) and return $tx->send({json => { error => "only one hand at a time, please" } });
       debug "$us: $us plays $ours";
       if (my $them = $room->has_partner($us)) {
           debug "$us: $us already has partner $them.";
           if (my $game = $room->playing($them)) {
             debug "$us: $them played already in game ".$game->id;
             $game->shoot($us => $ours);
             $c->notify($_ => $game) for $game->players;
             $room->leave_game($_) for $game->players;
             debug $game->summary;
           } else {
             debug "$us: new game";
             $room->add_game($us, $ours);
           }
       } else {
           if (my $game = $room->want_game($us, $ours)) {
             debug "$us: found a game to play ".$game->id;
             debug Dumper($game);
             $game->shoot($us => $ours);
             $game->set or die "issue with game";
             $c->notify($_ => $game) for $game->players;
             $room->pair_up($game->players);
             debug $game->summary;
             $room->leave_game($_) for $game->players;
           } else {
             #$room->once("seek", sub ($room, $them, $game) {
             #   debug "$us: found a seek by $them";
             #$game->shoot($us => $ours);
                #   $c->notify($_ => $game) for $game->players;
                #   $room->pair_up($game->players);
                #  debug $game->summary;
                #$room->leave_game($_) for $game->players;
                #});
           }
       }
     });
  });
};

Mojo::IOLoop->singleton->reactor->on(error => sub($io,$err) {
  debug "error: $err";
});

app->start;

__DATA__
@@ exception.html.ep
%== $exception
